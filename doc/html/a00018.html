<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4Yell: Tpy::Client::ChannelTypeCallInterface Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.6.2 -->
  <div class="navpath"><a class="el" href="a00091.html">Tpy</a>::<a class="el" href="a00092.html">Client</a>::<a class="el" href="a00018.html">ChannelTypeCallInterface</a>
  </div>
<div class="contents">
<h1>Tpy::Client::ChannelTypeCallInterface Class Reference</h1><!-- doxytag: class="Tpy::Client::ChannelTypeCallInterface" -->
<p><code>#include &lt;<a class="el" href="a00060_source.html">TelepathyQt4Yell/Channel</a>&gt;</code></p>

<p><a href="a00140.html">List of all members.</a></p>
<h2>Public Slots</h2>
<ul>
<li>QDBusPendingReply <a class="el" href="a00018.html#ae2b1e36b4cd6fec448a6d5efa8eb5fbe">SetRinging</a> (int timeout=-1)
<li>QDBusPendingReply <a class="el" href="a00018.html#aa40b5de2ee0e7da03124f2e2b09aa46a">Accept</a> (int timeout=-1)
<li>QDBusPendingReply <a class="el" href="a00018.html#a254e821507c4bafe3e0a1f0e820c05b8">Hangup</a> (uint reason, const QString &amp;detailedHangupReason, const QString &amp;message, int timeout=-1)
<li>QDBusPendingReply<br class="typebreak"/>
&lt; QDBusObjectPath &gt; <a class="el" href="a00018.html#a0ed07e37e4e5c6e744580a9bee15f898">AddContent</a> (const QString &amp;contentName, uint contentType, int timeout=-1)
</ul>
<h2>Signals</h2>
<ul>
<li>void <a class="el" href="a00018.html#a88f68a21f80a1587d66483c98f3fac62">ContentAdded</a> (const QDBusObjectPath &amp;content)
<li>void <a class="el" href="a00018.html#a96b2ecdde0707a7c67e8080d9d315c99">ContentRemoved</a> (const QDBusObjectPath &amp;content)
<li>void <a class="el" href="a00018.html#ac1258681aca9f7418cc65a6e4411f929">CallStateChanged</a> (uint callState, uint callFlags, const <a class="el" href="a00008.html">Tpy::CallStateReason</a> &amp;callStateReason, const QVariantMap &amp;callStateDetails)
<li>void <a class="el" href="a00018.html#af0befc3dd2846892c61b11b81c306692">CallMembersChanged</a> (const <a class="el" href="a00007.html">Tpy::CallMemberMap</a> &amp;flagsChanged, const <a class="el" href="a00038.html">Tpy::UIntList</a> &amp;removed)
</ul>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="a00018.html#ac0f6f651a9f97061ec4c9d0b318c55a1">ChannelTypeCallInterface</a> (const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="a00018.html#a7ceaacceb0b00b2b452068d84918b2cb">ChannelTypeCallInterface</a> (const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)
<li><a class="el" href="a00018.html#a25cc79c1c4aa791314daa5c953c7ade2">ChannelTypeCallInterface</a> (Tp::DBusProxy *proxy)
<li><a class="el" href="a00018.html#ad24ec50f635ea7fd4f22883c2941c5c2">ChannelTypeCallInterface</a> (const Tp::Client::ChannelInterface &amp;mainInterface)
<li><a class="el" href="a00018.html#ac31520151b24fafbcb36e9064b0a0989">ChannelTypeCallInterface</a> (const Tp::Client::ChannelInterface &amp;mainInterface, QObject *parent)
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a3e820a513533d35682ad6325588ae148">requestPropertyContents</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a3d9202e6fefb882eb9aa0cf01dc9dab0">requestPropertyCallStateDetails</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a177985d5185f409fcbf4e6753b68cb70">requestPropertyCallState</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a512b8c5b2f4edd029ecf2448b81a423e">requestPropertyCallFlags</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#ab962a18488dccb15c67bc8025a1ac20f">requestPropertyCallStateReason</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a6dd35dace3826b54af6779dc0462d6ef">requestPropertyHardwareStreaming</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a10f10aae704a5f1e654d1897303520dc">requestPropertyCallMembers</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a9d3388444bacda7c27d0da5dd4881b47">requestPropertyInitialTransport</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#af1b0d1807ee57a5c25a719f89e2380d8">requestPropertyInitialAudio</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#afa8028cd165d1dbe05fa8a5da1ca76d5">requestPropertyInitialVideo</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#ab69d3b87122d6bb70e9cb9f3b0aad962">requestPropertyInitialAudioName</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#a56be9723b6721deb3f179303a6d5111c">requestPropertyInitialVideoName</a> () const 
<li>Tp::PendingVariant * <a class="el" href="a00018.html#ae80ae73dd293c90f42dd14743cfe7db6">requestPropertyMutableContents</a> () const 
<li>Tp::PendingVariantMap * <a class="el" href="a00018.html#aabdc5086d96b4e44f068ef9f0fdd4ab9">requestAllProperties</a> () const 
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static QLatin1String <a class="el" href="a00018.html#a6b8c43fe8a642f3db8bb84e10868252c">staticInterfaceName</a> ()
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li>virtual void <a class="el" href="a00018.html#a1e29c82f347b6b7adb46f0e123c47ad5">invalidate</a> (Tp::DBusProxy *, const QString &amp;, const QString &amp;)
</ul>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Proxy class providing a 1:1 mapping of the D-Bus interface "org.freedesktop.Telepathy.Channel.Type.Call.DRAFT." </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac0f6f651a9f97061ec4c9d0b318c55a1"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface" ref="ac0f6f651a9f97061ec4c9d0b318c55a1" args="(const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00018.html">ChannelTypeCallInterface</a> associated with the given object on the session bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ceaacceb0b00b2b452068d84918b2cb"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface" ref="a7ceaacceb0b00b2b452068d84918b2cb" args="(const QDBusConnection &amp;connection, const QString &amp;busName, const QString &amp;objectPath, QObject *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface </td>
          <td>(</td>
          <td class="paramtype">const QDBusConnection &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>busName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00018.html">ChannelTypeCallInterface</a> associated with the given object on the given bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>The bus via which the object can be reached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busName</em>&nbsp;</td><td>Name of the service the object is on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>Path to the object on the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25cc79c1c4aa791314daa5c953c7ade2"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface" ref="a25cc79c1c4aa791314daa5c953c7ade2" args="(Tp::DBusProxy *proxy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface </td>
          <td>(</td>
          <td class="paramtype">Tp::DBusProxy *&nbsp;</td>
          <td class="paramname"> <em>proxy</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00018.html">ChannelTypeCallInterface</a> associated with the same object as the given proxy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>proxy</em>&nbsp;</td><td>The proxy to use. It will also be the QObject::parent() for this object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad24ec50f635ea7fd4f22883c2941c5c2"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface" ref="ad24ec50f635ea7fd4f22883c2941c5c2" args="(const Tp::Client::ChannelInterface &amp;mainInterface)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface </td>
          <td>(</td>
          <td class="paramtype">const Tp::Client::ChannelInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00018.html">ChannelTypeCallInterface</a> associated with the same object as the given proxy. Additionally, the created proxy will have the same parent as the given proxy.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac31520151b24fafbcb36e9064b0a0989"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface" ref="ac31520151b24fafbcb36e9064b0a0989" args="(const Tp::Client::ChannelInterface &amp;mainInterface, QObject *parent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpy::Client::ChannelTypeCallInterface::ChannelTypeCallInterface </td>
          <td>(</td>
          <td class="paramtype">const Tp::Client::ChannelInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>mainInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QObject *&nbsp;</td>
          <td class="paramname"> <em>parent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a <a class="el" href="a00018.html">ChannelTypeCallInterface</a> associated with the same object as the given proxy. However, a different parent object can be specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mainInterface</em>&nbsp;</td><td>The proxy to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parent</em>&nbsp;</td><td>Passed to the parent class constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6b8c43fe8a642f3db8bb84e10868252c"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::staticInterfaceName" ref="a6b8c43fe8a642f3db8bb84e10868252c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static QLatin1String Tpy::Client::ChannelTypeCallInterface::staticInterfaceName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the name of the interface "org.freedesktop.Telepathy.Channel.Type.Call.DRAFT", which this class represents.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The D-Bus interface name. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e820a513533d35682ad6325588ae148"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyContents" ref="a3e820a513533d35682ad6325588ae148" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyContents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "Contents" of type <a class="el" href="a00026.html">Tpy::ObjectPathList</a>.</p>
<p>The list of &lt;tp:dbus-ref namespace="ofdT.Call"&gt;Content.DRAFT&lt;/tp:dbus-ref&gt; objects that are part of this call. Change notification is via the &lt;tp:member-ref&gt;ContentAdded&lt;/tp:member-ref&gt; and &lt;tp:member-ref&gt;ContentRemoved&lt;/tp:member-ref&gt; signals. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d9202e6fefb882eb9aa0cf01dc9dab0"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyCallStateDetails" ref="a3d9202e6fefb882eb9aa0cf01dc9dab0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyCallStateDetails </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "CallStateDetails" of type QVariantMap.</p>
<p>A map used to provide optional extensible details for the &lt;tp:member-ref&gt;CallState&lt;/tp:member-ref&gt;, &lt;tp:member-ref&gt;CallFlags&lt;/tp:member-ref&gt; and/or &lt;tp:member-ref&gt;<a class="el" href="a00008.html">CallStateReason</a>&lt;/tp:member-ref&gt;.</p>
<p>Well-known keys and their corresponding value types include:</p>
<dl>
<dt>hangup-message - s </dt>
<dd><p class="startdd">An optional human-readable message sent when the call was ended, corresponding to the Message argument to the &lt;tp:member-ref&gt;Hangup&lt;/tp:member-ref&gt; method. This is only applicable when the call state is &lt;tp:type&gt;Call_State&lt;/tp:type&gt;_Ended. &lt;tp:rationale&gt; XMPP Jingle can send such messages. &lt;/tp:rationale&gt; </p>
<p class="enddd"></p>
</dd>
<dt>queue-message - s </dt>
<dd><p class="startdd">An optional human-readable message sent when the local contact is being held in a queue. This is only applicable when &lt;tp:type&gt;Call_Flags&lt;/tp:type&gt;_Queued is in the call flags. &lt;tp:rationale&gt; SIP 182 notifications can have human-readable messages attached. &lt;/tp:rationale&gt; </p>
<p class="enddd"></p>
</dd>
<dt>debug-message - s </dt>
<dd>A message giving further details of any error indicated by the &lt;tp:member-ref&gt;<a class="el" href="a00008.html">CallStateReason</a>&lt;/tp:member-ref&gt;. This will not normally be localized or suitable for display to users, and is only applicable when the call state is &lt;tp:type&gt;Call_State&lt;/tp:type&gt;_Ended. </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a177985d5185f409fcbf4e6753b68cb70"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyCallState" ref="a177985d5185f409fcbf4e6753b68cb70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyCallState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "CallState" of type uint.</p>
<p>The current high-level state of this call. The &lt;tp:member-ref&gt;CallFlags&lt;/tp:member-ref&gt; provide additional information, and the &lt;tp:member-ref&gt;<a class="el" href="a00008.html">CallStateReason</a>&lt;/tp:member-ref&gt; and &lt;tp:member-ref&gt;CallStateDetails&lt;/tp:member-ref&gt; explain the reason for the current values for those properties.</p>
<p>Note that when in a conference call, this property is purely to show your state in joining the call. The receiver (or remote contact) in this context is the conference server itself. The property does not change when other call members' states change.</p>
<p>Clients MAY consider unknown values in this property to be an error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a512b8c5b2f4edd029ecf2448b81a423e"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyCallFlags" ref="a512b8c5b2f4edd029ecf2448b81a423e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyCallFlags </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "CallFlags" of type uint.</p>
<p>Flags representing the status of the call as a whole, providing more specific information than the &lt;tp:member-ref&gt;CallState&lt;/tp:member-ref&gt;.</p>
<p>Clients are expected to ignore unknown flags in this property, without error.</p>
<p>When an ongoing call is active and not on hold or has any other problems, this property will be 0.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ab962a18488dccb15c67bc8025a1ac20f"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyCallStateReason" ref="ab962a18488dccb15c67bc8025a1ac20f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyCallStateReason </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "CallStateReason" of type <a class="el" href="a00008.html">Tpy::CallStateReason</a>.</p>
<p>The reason for the last change to the &lt;tp:member-ref&gt;CallState&lt;/tp:member-ref&gt; and/or &lt;tp:member-ref&gt;CallFlags&lt;/tp:member-ref&gt;. The &lt;tp:member-ref&gt;CallStateDetails&lt;/tp:member-ref&gt; MAY provide additional information.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a6dd35dace3826b54af6779dc0462d6ef"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyHardwareStreaming" ref="a6dd35dace3826b54af6779dc0462d6ef" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyHardwareStreaming </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "HardwareStreaming" of type bool.</p>
<p>If this property is True, all of the media streaming is done by some mechanism outside the scope of Telepathy.</p>
<p>&lt;tp:rationale&gt; </p>
<p>A connection manager might be intended for a specialized hardware device, which will take care of the audio streaming (e.g. telepathy-yafono, which uses GSM hardware which does the actual audio streaming for the call). &lt;/tp:rationale&gt;</p>
<p>If this is False, the handler is responsible for doing the actual media streaming for at least some contents itself. Those contents will have the &lt;tp:dbus-ref namespace="ofdT.Call.Content.Interface"&gt;Media.DRAFT&lt;/tp:dbus-ref&gt; interface, to communicate the necessary information to a streaming implementation. Connection managers SHOULD operate like this, if possible.</p>
<p>&lt;tp:rationale&gt; </p>
<p>Many connection managers (such as telepathy-gabble) only do the call signalling, and expect the client to do the actual streaming using something like <a href="http://farsight.freedesktop.org/">Farsight</a>, to improve latency and allow better UI integration. &lt;/tp:rationale&gt;</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a10f10aae704a5f1e654d1897303520dc"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyCallMembers" ref="a10f10aae704a5f1e654d1897303520dc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyCallMembers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "CallMembers" of type <a class="el" href="a00007.html">Tpy::CallMemberMap</a>.</p>
<p>A mapping from the remote contacts that are part of this call to flags describing their status. This mapping never has the local user's handle as a key.</p>
<p>When the call ends, this property should be an empty list, and notified with &lt;tp:member-ref&gt;CallMembersChanged&lt;/tp:member-ref&gt;</p>
<p>If the Call implements &lt;tp:dbus-ref namespace="ofdT.Channel.Interface"&gt;Group&lt;/tp:dbus-ref&gt; and the Group members are channel-specific handles, then this call SHOULD also use channel-specific handles.</p>
<p>Anonymous members are exposed as channel-specific handles with no owner.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d3388444bacda7c27d0da5dd4881b47"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialTransport" ref="a9d3388444bacda7c27d0da5dd4881b47" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialTransport </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "InitialTransport" of type uint.</p>
<p>If set on a requested channel, this indicates the transport that should be used for this call. Where not applicable, this property is defined to be &lt;tp:type&gt;Stream_Transport_Type&lt;/tp:type&gt;_Unknown, in particular, on CMs with hardware streaming.</p>
<p>&lt;tp:rationale&gt; When implementing a voip gateway one wants the outgoing leg of the gatewayed to have the same transport as the incoming leg. This property allows the gateway to request a Call with the right transport from the CM. &lt;/tp:rationale&gt;</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="af1b0d1807ee57a5c25a719f89e2380d8"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialAudio" ref="af1b0d1807ee57a5c25a719f89e2380d8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialAudio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "InitialAudio" of type bool.</p>
<p>If set to True in a channel request that will create a new channel, the connection manager should immediately attempt to establish an audio stream to the remote contact, making it unnecessary for the client to call &lt;tp:dbus-ref namespace="ofdT.Channel.Type.Call.DRAFT"&gt;AddContent&lt;/tp:dbus-ref&gt;.</p>
<p>If this property, or InitialVideo, is passed to EnsureChannel (as opposed to CreateChannel), the connection manager SHOULD ignore these properties when checking whether it can return an existing channel as suitable; these properties only become significant when the connection manager has decided to create a new channel.</p>
<p>If True on a requested channel, this indicates that the audio stream has already been requested and the client does not need to call RequestStreams, although it MAY still do so.</p>
<p>If True on an unrequested (incoming) channel, this indicates that the remote contact initially requested an audio stream; this does not imply that that audio stream is still active (as indicated by &lt;tp:dbus-ref namespace="ofdT.Channel.Type.Call.DRAFT"&gt;Contents&lt;/tp:dbus-ref&gt;).</p>
<p>The name of this new content can be decided by using the &lt;tp:member-ref&gt;InitialAudioName&lt;/tp:member-ref&gt; property.</p>
<p>Connection managers that support the &lt;tp:dbus-ref namespace="ofdT.Connection.Interface"&gt;<a class="el" href="a00021.html" title="The ContactCapabilities class provides an object representing the capabilities of...">ContactCapabilities</a>&lt;/tp:dbus-ref&gt; interface SHOULD represent the capabilities of receiving audio and/or video calls by including a channel class in a contact's capabilities with ChannelType = Call in the fixed properties dictionary, and InitialAudio and/or InitialVideo in the allowed properties list. Clients wishing to discover whether a particular contact is likely to be able to receive audio and/or video calls SHOULD use this information.</p>
<p>&lt;tp:rationale&gt; </p>
<p>Not all clients support video calls, and it would also be possible (although unlikely) to have a client which could only stream video, not audio. &lt;/tp:rationale&gt;</p>
<p>Clients that are willing to receive audio and/or video calls SHOULD include the following among their channel classes if calling &lt;tp:dbus-ref namespace="ofdT.Connection.Interface.ContactCapabilities"&gt;UpdateCapabilities&lt;/tp:dbus-ref&gt; (clients of a &lt;tp:dbus-ref namespace="org.freedesktop.Telepathy"&gt;ChannelDispatcher&lt;/tp:dbus-ref&gt; SHOULD instead arrange for the ChannelDispatcher to do this, by including the filters in their &lt;tp:dbus-ref namespace="ofdT.Client.Handler"&gt;HandlerChannelFilter&lt;/tp:dbus-ref&gt; properties):</p>
<ul>
<li>
{ ChannelType = Call } </li>
<li>
{ ChannelType = Call, InitialAudio = True } if receiving calls with audio is supported </li>
<li>
{ ChannelType = Call, InitialVideo = True } if receiving calls with video is supported </li>
</ul>
<p>&lt;tp:rationale&gt; </p>
<p>Connection managers for protocols with capability discovery, like XMPP, need this information to advertise the appropriate capabilities for their protocol. &lt;/tp:rationale&gt;</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="afa8028cd165d1dbe05fa8a5da1ca76d5"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialVideo" ref="afa8028cd165d1dbe05fa8a5da1ca76d5" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialVideo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "InitialVideo" of type bool.</p>
<p>The same as &lt;tp:member-ref&gt;InitialAudio&lt;/tp:member-ref&gt;, but for a video stream. This property is immutable (cannot change).</p>
<p>In particular, note that if this property is False, this does not imply that an active video stream has not been added, only that no video stream was active at the time the channel appeared.</p>
<p>This property is the correct way to discover whether connection managers, contacts etc. support video calls; it appears in capabilities structures in the same way as InitialAudio.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ab69d3b87122d6bb70e9cb9f3b0aad962"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialAudioName" ref="ab69d3b87122d6bb70e9cb9f3b0aad962" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialAudioName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "InitialAudioName" of type QString.</p>
<p>If &lt;tp:member-ref&gt;InitialAudio&lt;/tp:member-ref&gt; is set to True, then this property will name the intial audio content with the value of this property.</p>
<p>&lt;tp:rationale&gt; </p>
<p>Content names are meant to be significant, but if no name can be given to initial audio content, then its name cannot be meaningful or even localized. &lt;/tp:rationale&gt;</p>
<p>If this property is empty or missing from the channel request and InitialAudio is True, then the CM must come up with a sensible for the content, such as "audio".</p>
<p>If the protocol has no concept of stream names then this property will not show up in the allowed properties list of the Requestable Channel Classes for call channels.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="a56be9723b6721deb3f179303a6d5111c"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialVideoName" ref="a56be9723b6721deb3f179303a6d5111c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyInitialVideoName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "InitialVideoName" of type QString.</p>
<p>The same as &lt;tp:member-ref&gt;InitialAudioName&lt;/tp:member-ref&gt;, but for a video stream created by setting &lt;tp:member-ref&gt;InitialVideo&lt;/tp:member-ref&gt; to True. This property is immutable and so cannot change.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ae80ae73dd293c90f42dd14743cfe7db6"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestPropertyMutableContents" ref="ae80ae73dd293c90f42dd14743cfe7db6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariant* Tpy::Client::ChannelTypeCallInterface::requestPropertyMutableContents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronous getter for the remote object property "MutableContents" of type bool.</p>
<p>If True, a stream of a different content type can be added after the Channel has been requested </p>
<p>If this property is missing, clients SHOULD assume that it is False, and thus that the channel's streams cannot be changed once the call has started.</p>
<p>If this property isn't present in the "allowed" set in any of the Call entries contact capabilities, then user interfaces MAY choose to show a separate "call" option for each class of call.</p>
<p>&lt;tp:rationale&gt; </p>
<p>For example, once an audio-only Google Talk call has started, it is not possible to add a video stream; both audio and video must be requested at the start of the call if video is desired. User interfaces may use this pseudo-capability as a hint to display separate "Audio call" and "Video call" buttons, rather than a single "Call" button with the option to add and remove video once the call has started for contacts without this flag.  &lt;/tp:rationale&gt;</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant which will emit finished when the property has been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="aabdc5086d96b4e44f068ef9f0fdd4ab9"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::requestAllProperties" ref="aabdc5086d96b4e44f068ef9f0fdd4ab9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingVariantMap* Tpy::Client::ChannelTypeCallInterface::requestAllProperties </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request all of the DBus properties on the interface.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pending variant map which will emit finished when the properties have been retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2b1e36b4cd6fec448a6d5efa8eb5fbe"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::SetRinging" ref="ae2b1e36b4cd6fec448a6d5efa8eb5fbe" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply Tpy::Client::ChannelTypeCallInterface::SetRinging </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method "SetRinging" on the remote object.</p>
<p>Indicate that the local user has been alerted about the incoming call.</p>
<p>This method is only useful if the channel's &lt;tp:dbus-ref namespace="ofdT.Channel"&gt;Requested&lt;/tp:dbus-ref&gt; property is False, and the &lt;tp:member-ref&gt;CallState&lt;/tp:member-ref&gt; is &lt;tp:type&gt;Call_State&lt;/tp:type&gt;_Pending_Receiver (an incoming call waiting on the local user to pick up). While this is the case, this method SHOULD change the &lt;tp:member-ref&gt;CallFlags&lt;/tp:member-ref&gt; to include &lt;tp:type&gt;Call_Flags&lt;/tp:type&gt;_Locally_Ringing, and notify the remote contact that the local user has been alerted (if the protocol implements this); repeated calls to this method SHOULD succeed, but have no further effect.</p>
<p>In all other states, this method SHOULD fail with the error NotAvailable.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa40b5de2ee0e7da03124f2e2b09aa46a"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::Accept" ref="aa40b5de2ee0e7da03124f2e2b09aa46a" args="(int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply Tpy::Client::ChannelTypeCallInterface::Accept </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method "Accept" on the remote object.</p>
<p>For incoming calls in state &lt;tp:type&gt;Call_State&lt;/tp:type&gt;_Pending_Receiver, accept the incoming call; this changes the &lt;tp:member-ref&gt;CallState&lt;/tp:member-ref&gt; to &lt;tp:type&gt;Call_State&lt;/tp:type&gt;_Accepted.</p>
<p>For outgoing calls in state &lt;tp:type&gt;Call_State&lt;/tp:type&gt;_Pending_Initiator, actually call the remote contact; this changes the &lt;tp:member-ref&gt;CallState&lt;/tp:member-ref&gt; to &lt;tp:type&gt;Call_State&lt;/tp:type&gt;_Pending_Receiver.</p>
<p>Otherwise, this method SHOULD fail with the error NotAvailable.</p>
<p>This method should be called exactly once per Call, by whatever client (user interface) is handling the channel.</p>
<p>When this method is called, for each &lt;tp:dbus-ref namespace="ofdT.Call"&gt;Content.DRAFT&lt;/tp:dbus-ref&gt; whose &lt;tp:dbus-ref namespace="ofdT.Call.Content.DRAFT"&gt;Disposition&lt;/tp:dbus-ref&gt; is &lt;tp:type&gt;Call_Content_Disposition&lt;/tp:type&gt;_Initial, any streams where the &lt;tp:dbus-ref namespace="ofdT.Call.Stream.DRAFT"&gt;LocalSendingState&lt;/tp:dbus-ref&gt; is &lt;tp:type&gt;Sending_State&lt;/tp:type&gt;_Pending_Send will be moved to &lt;tp:type&gt;Sending_State&lt;/tp:type&gt;_Sending as if &lt;tp:dbus-ref namespace="ofdT.Call.Stream.DRAFT"&gt;SetSending&lt;/tp:dbus-ref&gt;(True) had been called.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a254e821507c4bafe3e0a1f0e820c05b8"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::Hangup" ref="a254e821507c4bafe3e0a1f0e820c05b8" args="(uint reason, const QString &amp;detailedHangupReason, const QString &amp;message, int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply Tpy::Client::ChannelTypeCallInterface::Hangup </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>detailedHangupReason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method "Hangup" on the remote object.</p>
<p>Request that the call is ended. All contents will be removed from the Call so that the Contents property will be the empty list.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>A generic hangup reason.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detailedHangupReason</em>&nbsp;</td><td>A more specific reason for the call hangup, if one is available, or an empty string otherwise.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A human-readable message to be sent to the remote contact(s). XMPP Jingle allows calls to be terminated with a human-readable message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout in milliseconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ed07e37e4e5c6e744580a9bee15f898"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::AddContent" ref="a0ed07e37e4e5c6e744580a9bee15f898" args="(const QString &amp;contentName, uint contentType, int timeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QDBusPendingReply&lt;QDBusObjectPath&gt; Tpy::Client::ChannelTypeCallInterface::AddContent </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>contentName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>contentType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, slot]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begins a call to the D-Bus method "AddContent" on the remote object.</p>
<p>Request that a new Content.DRAFT of type Content_Type is added to the Call. Handlers should check the value of the MutableContents property before trying to add another content as it might not be allowed.</p>
<p>Note that <em>timeout</em> is ignored as of now. It will be used once <a href="http://bugreports.qt.nokia.com/browse/QTBUG-11775">http://bugreports.qt.nokia.com/browse/QTBUG-11775</a> is fixed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contentName</em>&nbsp;</td><td>The suggested name of the content to add. The content name property should be meaningful, so should be given a name which is significant to the user. The name could be a localized "audio", "video" or perhaps include some string identifying the source, such as a webcam identifier. If there is already a content with the same name as this property then a sensible suffix should be added. For example, if this argument is "audio" but a content of the same name already exists, a sensible suffix such as " (1)" is appended to name the new content "audio (1)". A further content with the name "audio" would then be named "audio (2)".</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentType</em>&nbsp;</td><td>The media stream type of the content to be added to the call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>Path to the newly-created Call.Content.DRAFT object. </p>

</div>
</div>
<a class="anchor" id="a88f68a21f80a1587d66483c98f3fac62"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::ContentAdded" ref="a88f68a21f80a1587d66483c98f3fac62" args="(const QDBusObjectPath &amp;content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::Client::ChannelTypeCallInterface::ContentAdded </td>
          <td>(</td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>content</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents the signal "ContentAdded" on the remote object.</p>
<p>Emitted when a new &lt;tp:dbus-ref namespace="ofdT.Call"&gt;Content.DRAFT&lt;/tp:dbus-ref&gt; is added to the call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>Path to the newly-created Content.DRAFT object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96b2ecdde0707a7c67e8080d9d315c99"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::ContentRemoved" ref="a96b2ecdde0707a7c67e8080d9d315c99" args="(const QDBusObjectPath &amp;content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::Client::ChannelTypeCallInterface::ContentRemoved </td>
          <td>(</td>
          <td class="paramtype">const QDBusObjectPath &amp;&nbsp;</td>
          <td class="paramname"> <em>content</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents the signal "ContentRemoved" on the remote object.</p>
<p>Emitted when a &lt;tp:dbus-ref namespace="ofdT.Call"&gt;Content.DRAFT&lt;/tp:dbus-ref&gt; is removed from the call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>The Content.DRAFT which was removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1258681aca9f7418cc65a6e4411f929"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::CallStateChanged" ref="ac1258681aca9f7418cc65a6e4411f929" args="(uint callState, uint callFlags, const Tpy::CallStateReason &amp;callStateReason, const QVariantMap &amp;callStateDetails)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::Client::ChannelTypeCallInterface::CallStateChanged </td>
          <td>(</td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>callState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&nbsp;</td>
          <td class="paramname"> <em>callFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00008.html">Tpy::CallStateReason</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callStateReason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>callStateDetails</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents the signal "CallStateChanged" on the remote object.</p>
<p>Emitted when the state of the call as a whole changes.</p>
<p>This signal is emitted for any change in the properties corresponding to its arguments, even if the other properties referenced remain unchanged.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>callState</em>&nbsp;</td><td>The new value of the CallState property.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callFlags</em>&nbsp;</td><td>The new value of the CallFlags property.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callStateReason</em>&nbsp;</td><td>The new value of the <a class="el" href="a00008.html">CallStateReason</a> property.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callStateDetails</em>&nbsp;</td><td>The new value of the CallStateDetails property. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0befc3dd2846892c61b11b81c306692"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::CallMembersChanged" ref="af0befc3dd2846892c61b11b81c306692" args="(const Tpy::CallMemberMap &amp;flagsChanged, const Tpy::UIntList &amp;removed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::Client::ChannelTypeCallInterface::CallMembersChanged </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html">Tpy::CallMemberMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>flagsChanged</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00038.html">Tpy::UIntList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>removed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents the signal "CallMembersChanged" on the remote object.</p>
<p>Emitted when the CallMembers property changes in any way, either because contacts have been added to the call, contacts have been removed from the call, or contacts' flags have changed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flagsChanged</em>&nbsp;</td><td>A map from members of the call to their new call member flags, including at least the members who have been added to CallMembers, and the members whose flags have changed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>removed</em>&nbsp;</td><td>A list of members who have left the call, i.e. keys to be removed from CallMembers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e29c82f347b6b7adb46f0e123c47ad5"></a><!-- doxytag: member="Tpy::Client::ChannelTypeCallInterface::invalidate" ref="a1e29c82f347b6b7adb46f0e123c47ad5" args="(Tp::DBusProxy *, const QString &amp;, const QString &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::Client::ChannelTypeCallInterface::invalidate </td>
          <td>(</td>
          <td class="paramtype">Tp::DBusProxy *&nbsp;</td>
          <td class="paramname"> <em>proxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2010 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4-Yell 0.1.4</div></td>
</tr></table></div></address>
</body>
</html>
