<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>TelepathyQt4Yell: Tpy::CallChannel Class Reference</title>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
<tr>
<td width="1">&nbsp;&nbsp;</td>
<td class="postheader" valign="center">
<a href="index.html">
<font color="#004faf">Home</font></a>&nbsp;&middot;
<a href="classes.html">
<font color="#004faf">All Classes</font></a>&nbsp;&middot;
<a href="namespaces.html">
<font color="#004faf">All Namespaces</font></a>&nbsp;&middot;
<a href="modules.html">
<font color="#004faf">Modules</font></a>&nbsp;&middot;
<a href="functions.html">
<font color="#004faf">Functions</font></a>&nbsp;&middot;
<a href="files.html">
<font color="#004faf">Files</font></a>
</td>
</tr>
</table>
</body>
</html>
<!-- Generated by Doxygen 1.6.2 -->
  <div class="navpath"><a class="el" href="a00091.html">Tpy</a>::<a class="el" href="a00001.html">CallChannel</a>
  </div>
<div class="contents">
<h1>Tpy::CallChannel Class Reference</h1><!-- doxytag: class="Tpy::CallChannel" -->
<p>The <a class="el" href="a00001.html" title="The CallChannel class provides an object representing a Telepathy channel of type...">CallChannel</a> class provides an object representing a Telepathy channel of type Call.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00048_source.html">TelepathyQt4Yell/CallChannel</a>&gt;</code></p>

<p><a href="a00106.html">List of all members.</a></p>
<h2>Signals</h2>
<ul>
<li>void <a class="el" href="a00001.html#af79b74397a87c5818fc59428ded9716e">contentAdded</a> (const <a class="el" href="a00091.html#a8356b5eb02e12646a33709f5cd517a7d">Tpy::CallContentPtr</a> &amp;content)
<li>void <a class="el" href="a00001.html#ac8e4f737e1aac32d6892125cce5f6d85">contentRemoved</a> (const <a class="el" href="a00091.html#a8356b5eb02e12646a33709f5cd517a7d">Tpy::CallContentPtr</a> &amp;content)
<li>void <a class="el" href="a00001.html#a3dfe4df31f95d5f046913bbfea5bd8f2">stateChanged</a> (<a class="el" href="a00094.html#gae90705bbfbe5157d5615179420e6be05">Tpy::CallState</a> state)
<li>void <a class="el" href="a00001.html#ac9deaeab1820efba5a202d5364d48177">localHoldStateChanged</a> (Tp::LocalHoldState state, Tp::LocalHoldStateReason reason)
</ul>
<h2>Public Member Functions</h2>
<ul>
<li>virtual <a class="el" href="a00001.html#a112dfb2f2a8a7389e11f494913c6b4ac">~CallChannel</a> ()
<li><a class="el" href="a00094.html#gae90705bbfbe5157d5615179420e6be05">CallState</a> <a class="el" href="a00001.html#ac6c7a6f9700d13532c21f1e0609d1536">state</a> () const 
<li><a class="el" href="a00093.html#ga79f1b53c4dac776b32e24829aa480355">CallFlags</a> <a class="el" href="a00001.html#adb73f115a5635f7c9074eb919bead045">flags</a> () const 
<li><a class="el" href="a00008.html">CallStateReason</a> <a class="el" href="a00001.html#a0c4a21281187f84eb2831a98576375cb">stateReason</a> () const 
<li>QVariantMap <a class="el" href="a00001.html#ad3c50b04d597c51a885933a71327fa14">stateDetails</a> () const 
<li>bool <a class="el" href="a00001.html#a6311123ccb371d5636a64306dd85ee24">handlerStreamingRequired</a> () const 
<li><a class="el" href="a00094.html#gac71a0a0c5e4d052a1e9acb0501591da0">StreamTransportType</a> <a class="el" href="a00001.html#a2847fe255699a4067ff6ac558068f0b4">initialTransportType</a> () const 
<li>bool <a class="el" href="a00001.html#a8db630b3fa5e548c659753ba05085bb7">hasInitialAudio</a> () const 
<li>bool <a class="el" href="a00001.html#a6ee9d48a0e50529aa74199f486ae5b5a">hasInitialVideo</a> () const 
<li>QString <a class="el" href="a00001.html#a5be36d593abf5bc51912e65b2d8f8acf">initialAudioName</a> () const 
<li>QString <a class="el" href="a00001.html#a30d0a226922c3f2912eaa75097efdb79">initialVideoName</a> () const 
<li>bool <a class="el" href="a00001.html#a4747df65da0819d572115243a73d37bd">hasMutableContents</a> () const 
<li>Tp::PendingOperation * <a class="el" href="a00001.html#a507f89ef5f2f79f9296ece0511439237">accept</a> ()
<li>Tp::PendingOperation * <a class="el" href="a00001.html#a9a7b17c7bdd31707ce5e75ea12105042">hangup</a> (<a class="el" href="a00094.html#ga20b8946c6b8c67ba63b611ef0eda74b3">CallStateChangeReason</a> reason, const QString &amp;detailedReason, const QString &amp;message)
<li><a class="el" href="a00091.html#adba4ea4271512f77ea1b0544f81f15fd">CallContents</a> <a class="el" href="a00001.html#a3367ed01aca621366108b00348b5e44b">contents</a> () const 
<li><a class="el" href="a00091.html#adba4ea4271512f77ea1b0544f81f15fd">CallContents</a> <a class="el" href="a00001.html#a57f52319525dca8275235c948edb5d15">contentsForType</a> (Tp::MediaStreamType type) const 
<li><a class="el" href="a00027.html">PendingCallContent</a> * <a class="el" href="a00001.html#a7189511868565b7788f8109f64e58cd0">requestContent</a> (const QString &amp;name, Tp::MediaStreamType type)
<li>Tp::PendingOperation * <a class="el" href="a00001.html#aa54a8d9cc00e9e83bf5659e46584e29d">removeContent</a> (const <a class="el" href="a00091.html#a8356b5eb02e12646a33709f5cd517a7d">CallContentPtr</a> &amp;content, <a class="el" href="a00094.html#ga903c56e6520902bab8b81d20a7acf31e">ContentRemovalReason</a> reason, const QString &amp;detailedReason, const QString &amp;message)
<li>Tp::LocalHoldState <a class="el" href="a00001.html#a48731ff335f6d808525c8c8fab9548ec">localHoldState</a> () const 
<li>Tp::LocalHoldStateReason <a class="el" href="a00001.html#af3caa6e2389c68b377e776df8756e4e0">localHoldStateReason</a> () const 
<li>Tp::PendingOperation * <a class="el" href="a00001.html#af2fb8b6aad626bf29d67176abc0e7591">requestHold</a> (bool hold)
</ul>
<h2>Static Public Member Functions</h2>
<ul>
<li>static <a class="el" href="a00091.html#a84c93de6bc8854a717c4e8a9a2232ce4">CallChannelPtr</a> <a class="el" href="a00001.html#a52bbacfb4a8b3a9e17a8b9101cdca50a">create</a> (const Tp::ConnectionPtr &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties)
</ul>
<h2>Static Public Attributes</h2>
<ul>
<li>static const Tp::Feature <a class="el" href="a00001.html#a90bdabe36db4890566aa817a2905cb2e">FeatureContents</a>
<li>static const Tp::Feature <a class="el" href="a00001.html#afb30df8bb87f1440e267ff9c45729587">FeatureLocalHoldState</a>
</ul>
<h2>Protected Member Functions</h2>
<ul>
<li><a class="el" href="a00001.html#a2da8fbbe72e2cb544757a8743cd4bd69">CallChannel</a> (const Tp::ConnectionPtr &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties, const Tp::Feature &amp;coreFeature=Tp::Channel::FeatureCore)
</ul>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="a00001.html" title="The CallChannel class provides an object representing a Telepathy channel of type...">CallChannel</a> class provides an object representing a Telepathy channel of type Call. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a112dfb2f2a8a7389e11f494913c6b4ac"></a><!-- doxytag: member="Tpy::CallChannel::~CallChannel" ref="a112dfb2f2a8a7389e11f494913c6b4ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpy::CallChannel::~CallChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Class destructor. </p>

</div>
</div>
<a class="anchor" id="a2da8fbbe72e2cb544757a8743cd4bd69"></a><!-- doxytag: member="Tpy::CallChannel::CallChannel" ref="a2da8fbbe72e2cb544757a8743cd4bd69" args="(const Tp::ConnectionPtr &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties, const Tp::Feature &amp;coreFeature=Tp::Channel::FeatureCore)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tpy::CallChannel::CallChannel </td>
          <td>(</td>
          <td class="paramtype">const Tp::ConnectionPtr &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>immutableProperties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tp::Feature &amp;&nbsp;</td>
          <td class="paramname"> <em>coreFeature</em> = <code>Tp::Channel::FeatureCore</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a new <a class="el" href="a00001.html" title="The CallChannel class provides an object representing a Telepathy channel of type...">CallChannel</a> associated with the given object on the same service as the given connection.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>Connection owning this channel, and specifying the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>The object path of this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>immutableProperties</em>&nbsp;</td><td>The immutable properties of this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coreFeature</em>&nbsp;</td><td>The core feature of the channel type. The corresponding introspectable should depend on Channel::FeatureCore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a52bbacfb4a8b3a9e17a8b9101cdca50a"></a><!-- doxytag: member="Tpy::CallChannel::create" ref="a52bbacfb4a8b3a9e17a8b9101cdca50a" args="(const Tp::ConnectionPtr &amp;connection, const QString &amp;objectPath, const QVariantMap &amp;immutableProperties)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00091.html#a84c93de6bc8854a717c4e8a9a2232ce4">CallChannelPtr</a> Tpy::CallChannel::create </td>
          <td>(</td>
          <td class="paramtype">const Tp::ConnectionPtr &amp;&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>objectPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariantMap &amp;&nbsp;</td>
          <td class="paramname"> <em>immutableProperties</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new <a class="el" href="a00001.html" title="The CallChannel class provides an object representing a Telepathy channel of type...">CallChannel</a> object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>Connection owning this channel, and specifying the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>objectPath</em>&nbsp;</td><td>The object path of this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>immutableProperties</em>&nbsp;</td><td>The immutable properties of this channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A CallChannelPtr object pointing to the newly created <a class="el" href="a00001.html" title="The CallChannel class provides an object representing a Telepathy channel of type...">CallChannel</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6c7a6f9700d13532c21f1e0609d1536"></a><!-- doxytag: member="Tpy::CallChannel::state" ref="ac6c7a6f9700d13532c21f1e0609d1536" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#gae90705bbfbe5157d5615179420e6be05">CallState</a> Tpy::CallChannel::state </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current state of this call.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current state of this call. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a3dfe4df31f95d5f046913bbfea5bd8f2">stateChanged()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adb73f115a5635f7c9074eb919bead045"></a><!-- doxytag: member="Tpy::CallChannel::flags" ref="adb73f115a5635f7c9074eb919bead045" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html#ga79f1b53c4dac776b32e24829aa480355">CallFlags</a> Tpy::CallChannel::flags </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the flags representing the status of this call as a whole, providing more specific information than <a class="el" href="a00001.html#ac6c7a6f9700d13532c21f1e0609d1536">state()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The flags representing the status of this call. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a3dfe4df31f95d5f046913bbfea5bd8f2">stateChanged()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c4a21281187f84eb2831a98576375cb"></a><!-- doxytag: member="Tpy::CallChannel::stateReason" ref="a0c4a21281187f84eb2831a98576375cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00008.html">CallStateReason</a> Tpy::CallChannel::stateReason </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the reason for the last change to the <a class="el" href="a00001.html#ac6c7a6f9700d13532c21f1e0609d1536">state()</a> and/or <a class="el" href="a00001.html#adb73f115a5635f7c9074eb919bead045">flags()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The reason for the last change to the <a class="el" href="a00001.html#ac6c7a6f9700d13532c21f1e0609d1536">state()</a> and/or <a class="el" href="a00001.html#adb73f115a5635f7c9074eb919bead045">flags()</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a3dfe4df31f95d5f046913bbfea5bd8f2">stateChanged()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3c50b04d597c51a885933a71327fa14"></a><!-- doxytag: member="Tpy::CallChannel::stateDetails" ref="ad3c50b04d597c51a885933a71327fa14" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVariantMap Tpy::CallChannel::stateDetails </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return optional extensible details for the <a class="el" href="a00001.html#ac6c7a6f9700d13532c21f1e0609d1536">state()</a>, <a class="el" href="a00001.html#adb73f115a5635f7c9074eb919bead045">flags()</a> and/or <a class="el" href="a00001.html#a0c4a21281187f84eb2831a98576375cb">stateReason()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The optional extensible details for the <a class="el" href="a00001.html#ac6c7a6f9700d13532c21f1e0609d1536">state()</a>, <a class="el" href="a00001.html#adb73f115a5635f7c9074eb919bead045">flags()</a> and/or <a class="el" href="a00001.html#a0c4a21281187f84eb2831a98576375cb">stateReason()</a>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a3dfe4df31f95d5f046913bbfea5bd8f2">stateChanged()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6311123ccb371d5636a64306dd85ee24"></a><!-- doxytag: member="Tpy::CallChannel::handlerStreamingRequired" ref="a6311123ccb371d5636a64306dd85ee24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tpy::CallChannel::handlerStreamingRequired </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check whether media streaming by the handler is required for this channel.</p>
<p>If <code>false</code>, all of the media streaming is done by some mechanism outside the scope of Telepathy, otherwise the handler is responsible for doing the actual media streaming.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if required, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2847fe255699a4067ff6ac558068f0b4"></a><!-- doxytag: member="Tpy::CallChannel::initialTransportType" ref="a2847fe255699a4067ff6ac558068f0b4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html#gac71a0a0c5e4d052a1e9acb0501591da0">StreamTransportType</a> Tpy::CallChannel::initialTransportType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the initial transport type used for this call if set on a requested channel.</p>
<p>Where not applicable, this property is defined to be <a class="el" href="a00091.html#gac71a0a0c5e4d052a1e9acb0501591da0a94d53b5f11361f774688c2ba779c705e">StreamTransportTypeUnknown</a>, in particular, on CMs with hardware streaming.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The initial transport type used for this call. </dd></dl>

</div>
</div>
<a class="anchor" id="a8db630b3fa5e548c659753ba05085bb7"></a><!-- doxytag: member="Tpy::CallChannel::hasInitialAudio" ref="a8db630b3fa5e548c659753ba05085bb7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tpy::CallChannel::hasInitialAudio </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether an audio content has already been requested.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if an audio content has already been requested, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ee9d48a0e50529aa74199f486ae5b5a"></a><!-- doxytag: member="Tpy::CallChannel::hasInitialVideo" ref="a6ee9d48a0e50529aa74199f486ae5b5a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tpy::CallChannel::hasInitialVideo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether a video content has already been requested.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if an video content has already been requested, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5be36d593abf5bc51912e65b2d8f8acf"></a><!-- doxytag: member="Tpy::CallChannel::initialAudioName" ref="a5be36d593abf5bc51912e65b2d8f8acf" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Tpy::CallChannel::initialAudioName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name of the initial audio content if <a class="el" href="a00001.html#a8db630b3fa5e548c659753ba05085bb7">hasInitialAudio()</a> returns <code>true</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the initial audio content. </dd></dl>

</div>
</div>
<a class="anchor" id="a30d0a226922c3f2912eaa75097efdb79"></a><!-- doxytag: member="Tpy::CallChannel::initialVideoName" ref="a30d0a226922c3f2912eaa75097efdb79" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString Tpy::CallChannel::initialVideoName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the name of the initial video content if <a class="el" href="a00001.html#a6ee9d48a0e50529aa74199f486ae5b5a">hasInitialVideo()</a> returns <code>true</code>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The name of the initial video content. </dd></dl>

</div>
</div>
<a class="anchor" id="a4747df65da0819d572115243a73d37bd"></a><!-- doxytag: member="Tpy::CallChannel::hasMutableContents" ref="a4747df65da0819d572115243a73d37bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Tpy::CallChannel::hasMutableContents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether a stream of a different content type can be added after the Channel has been requested.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if a stream of different content type can be added after the Channel has been requested, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a507f89ef5f2f79f9296ece0511439237"></a><!-- doxytag: member="Tpy::CallChannel::accept" ref="a507f89ef5f2f79f9296ece0511439237" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingOperation * Tpy::CallChannel::accept </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept an incoming call.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PendingOperation which will emit PendingOperation::finished when the call has finished. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a7b17c7bdd31707ce5e75ea12105042"></a><!-- doxytag: member="Tpy::CallChannel::hangup" ref="a9a7b17c7bdd31707ce5e75ea12105042" args="(CallStateChangeReason reason, const QString &amp;detailedReason, const QString &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingOperation * Tpy::CallChannel::hangup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html#ga20b8946c6b8c67ba63b611ef0eda74b3">CallStateChangeReason</a>&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>detailedReason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request that the call is ended.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Use hangupCall() instead.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>A generic hangup reason. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detailedReason</em>&nbsp;</td><td>A more specific reason for the call hangup, if one is available, or an empty string otherwise. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A human-readable message to be sent to the remote contact(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PendingOperation which will emit PendingOperation::finished when the call has finished. </dd></dl>

</div>
</div>
<a class="anchor" id="a3367ed01aca621366108b00348b5e44b"></a><!-- doxytag: member="Tpy::CallChannel::contents" ref="a3367ed01aca621366108b00348b5e44b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00091.html#adba4ea4271512f77ea1b0544f81f15fd">CallContents</a> Tpy::CallChannel::contents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a list of media contents in this channel.</p>
<p>This methods requires <a class="el" href="a00001.html#a90bdabe36db4890566aa817a2905cb2e">CallChannel::FeatureContents</a> to be enabled.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The contents in this channel. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#af79b74397a87c5818fc59428ded9716e">contentAdded()</a>, <a class="el" href="a00001.html#ac8e4f737e1aac32d6892125cce5f6d85">contentRemoved()</a>, <a class="el" href="a00001.html#a57f52319525dca8275235c948edb5d15">contentsForType()</a>, <a class="el" href="a00001.html#a7189511868565b7788f8109f64e58cd0">requestContent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a57f52319525dca8275235c948edb5d15"></a><!-- doxytag: member="Tpy::CallChannel::contentsForType" ref="a57f52319525dca8275235c948edb5d15" args="(Tp::MediaStreamType type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00091.html#adba4ea4271512f77ea1b0544f81f15fd">CallContents</a> Tpy::CallChannel::contentsForType </td>
          <td>(</td>
          <td class="paramtype">Tp::MediaStreamType&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a list of media contents in this channel for the given type <em>type</em>.</p>
<p>This methods requires <a class="el" href="a00001.html#a90bdabe36db4890566aa817a2905cb2e">CallChannel::FeatureContents</a> to be enabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The interested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A list of media contents in this channel for the given type <em>type</em>. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#af79b74397a87c5818fc59428ded9716e">contentAdded()</a>, <a class="el" href="a00001.html#ac8e4f737e1aac32d6892125cce5f6d85">contentRemoved()</a>, <a class="el" href="a00001.html#a3367ed01aca621366108b00348b5e44b">contents()</a>, <a class="el" href="a00001.html#a7189511868565b7788f8109f64e58cd0">requestContent()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7189511868565b7788f8109f64e58cd0"></a><!-- doxytag: member="Tpy::CallChannel::requestContent" ref="a7189511868565b7788f8109f64e58cd0" args="(const QString &amp;name, Tp::MediaStreamType type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00027.html">PendingCallContent</a> * Tpy::CallChannel::requestContent </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tp::MediaStreamType&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request that media content be established to exchange the given type <em>type</em> of media.</p>
<p>This methods requires <a class="el" href="a00001.html#a90bdabe36db4890566aa817a2905cb2e">CallChannel::FeatureContents</a> to be enabled.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A <a class="el" href="a00027.html">PendingCallContent</a> which will emit PendingCallContent::finished when the call has finished. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#af79b74397a87c5818fc59428ded9716e">contentAdded()</a>, <a class="el" href="a00001.html#a3367ed01aca621366108b00348b5e44b">contents()</a>, <a class="el" href="a00001.html#a57f52319525dca8275235c948edb5d15">contentsForType()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa54a8d9cc00e9e83bf5659e46584e29d"></a><!-- doxytag: member="Tpy::CallChannel::removeContent" ref="aa54a8d9cc00e9e83bf5659e46584e29d" args="(const CallContentPtr &amp;content, ContentRemovalReason reason, const QString &amp;detailedReason, const QString &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingOperation * Tpy::CallChannel::removeContent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00091.html#a8356b5eb02e12646a33709f5cd517a7d">CallContentPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00094.html#ga903c56e6520902bab8b81d20a7acf31e">ContentRemovalReason</a>&nbsp;</td>
          <td class="paramname"> <em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>detailedReason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the content.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>The content to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>A removal reason. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detailedReason</em>&nbsp;</td><td>A more specific reason for the removal, if one is available, or an empty string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message</em>&nbsp;</td><td>A human-readable message for the reason for the removal, such as "Fatal
                streaming failure" or "no codec intersection". This property can be left empty if no reason is to be given. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48731ff335f6d808525c8c8fab9548ec"></a><!-- doxytag: member="Tpy::CallChannel::localHoldState" ref="a48731ff335f6d808525c8c8fab9548ec" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::LocalHoldState Tpy::CallChannel::localHoldState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return whether the local user has placed this channel on hold.</p>
<p>This method requires CallChannel::FeatureHoldState to be enabled.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The channel local hold state. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#af2fb8b6aad626bf29d67176abc0e7591">requestHold()</a>, <a class="el" href="a00001.html#ac9deaeab1820efba5a202d5364d48177">localHoldStateChanged()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3caa6e2389c68b377e776df8756e4e0"></a><!-- doxytag: member="Tpy::CallChannel::localHoldStateReason" ref="af3caa6e2389c68b377e776df8756e4e0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::LocalHoldStateReason Tpy::CallChannel::localHoldStateReason </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the reason why <a class="el" href="a00001.html#a48731ff335f6d808525c8c8fab9548ec">localHoldState()</a> changed to its current value.</p>
<p>This method requires <a class="el" href="a00001.html#afb30df8bb87f1440e267ff9c45729587">CallChannel::FeatureLocalHoldState</a> to be enabled.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The channel local hold state reason. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#af2fb8b6aad626bf29d67176abc0e7591">requestHold()</a>, <a class="el" href="a00001.html#ac9deaeab1820efba5a202d5364d48177">localHoldStateChanged()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af2fb8b6aad626bf29d67176abc0e7591"></a><!-- doxytag: member="Tpy::CallChannel::requestHold" ref="af2fb8b6aad626bf29d67176abc0e7591" args="(bool hold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tp::PendingOperation * Tpy::CallChannel::requestHold </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>hold</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Request that the channel be put on hold (be instructed not to send any media streams to you) or be taken off hold.</p>
<p>If the connection manager can immediately tell that the requested state change could not possibly succeed, the resulting PendingOperation will fail with error code <a class="el" href="a00096.html#ga1746de0c5c2d044104b186ac603d2aed">TP_QT4_YELL_ERROR_NOT_AVAILABLE</a>. If the requested state is the same as the current state, the resulting PendingOperation will finish successfully.</p>
<p>Otherwise, the channel's local hold state will change to Tp::LocalHoldStatePendingHold or Tp::LocalHoldStatePendingUnhold (as appropriate), then the resulting PendingOperation will finish successfully.</p>
<p>The eventual success or failure of the request is indicated by a subsequent <a class="el" href="a00001.html#ac9deaeab1820efba5a202d5364d48177">localHoldStateChanged()</a> signal, changing the local hold state to Tp::LocalHoldStateHeld or Tp::LocalHoldStateUnheld.</p>
<p>If the channel has multiple streams, and the connection manager succeeds in changing the hold state of one stream but fails to change the hold state of another, it will attempt to revert all streams to their previous hold states.</p>
<p>If the channel does not support the TP_QT4_IFACE_CHANNEL_INTERFACE_HOLD interface, the PendingOperation will fail with error code <a class="el" href="a00096.html#gaf7e89521f04a6f80a262041545863b9d">TP_QT4_YELL_ERROR_NOT_IMPLEMENTED</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hold</em>&nbsp;</td><td>A boolean indicating whether or not the channel should be on hold </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A PendingOperation, which will emit PendingOperation::finished when the request finishes. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a48731ff335f6d808525c8c8fab9548ec">localHoldState()</a>, <a class="el" href="a00001.html#af3caa6e2389c68b377e776df8756e4e0">localHoldStateReason()</a>, <a class="el" href="a00001.html#ac9deaeab1820efba5a202d5364d48177">localHoldStateChanged()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af79b74397a87c5818fc59428ded9716e"></a><!-- doxytag: member="Tpy::CallChannel::contentAdded" ref="af79b74397a87c5818fc59428ded9716e" args="(const Tpy::CallContentPtr &amp;content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::CallChannel::contentAdded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00091.html#a8356b5eb02e12646a33709f5cd517a7d">Tpy::CallContentPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>content</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This signal is emitted when a media content is added to this channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>The media content that was added. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a3367ed01aca621366108b00348b5e44b">contents()</a>, <a class="el" href="a00001.html#a57f52319525dca8275235c948edb5d15">contentsForType()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac8e4f737e1aac32d6892125cce5f6d85"></a><!-- doxytag: member="Tpy::CallChannel::contentRemoved" ref="ac8e4f737e1aac32d6892125cce5f6d85" args="(const Tpy::CallContentPtr &amp;content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::CallChannel::contentRemoved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00091.html#a8356b5eb02e12646a33709f5cd517a7d">Tpy::CallContentPtr</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>content</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This signal is emitted when a media content is removed from this channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>The media content that was removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a3367ed01aca621366108b00348b5e44b">contents()</a>, <a class="el" href="a00001.html#a57f52319525dca8275235c948edb5d15">contentsForType()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3dfe4df31f95d5f046913bbfea5bd8f2"></a><!-- doxytag: member="Tpy::CallChannel::stateChanged" ref="a3dfe4df31f95d5f046913bbfea5bd8f2" args="(Tpy::CallState state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::CallChannel::stateChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html#gae90705bbfbe5157d5615179420e6be05">Tpy::CallState</a>&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9deaeab1820efba5a202d5364d48177"></a><!-- doxytag: member="Tpy::CallChannel::localHoldStateChanged" ref="ac9deaeab1820efba5a202d5364d48177" args="(Tp::LocalHoldState state, Tp::LocalHoldStateReason reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Tpy::CallChannel::localHoldStateChanged </td>
          <td>(</td>
          <td class="paramtype">Tp::LocalHoldState&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tp::LocalHoldStateReason&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [signal]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This signal is emitted when the local hold state of this channel changes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The new local hold state of this channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>The reason why the change occurred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="a00001.html#a48731ff335f6d808525c8c8fab9548ec">localHoldState()</a>, <a class="el" href="a00001.html#af3caa6e2389c68b377e776df8756e4e0">localHoldStateReason()</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a90bdabe36db4890566aa817a2905cb2e"></a><!-- doxytag: member="Tpy::CallChannel::FeatureContents" ref="a90bdabe36db4890566aa817a2905cb2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Tp::Feature <a class="el" href="a00001.html#a90bdabe36db4890566aa817a2905cb2e">Tpy::CallChannel::FeatureContents</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Feature used in order to access content specific methods.</p>
<p>See media content specific methods' documentation for more details. </p>

</div>
</div>
<a class="anchor" id="afb30df8bb87f1440e267ff9c45729587"></a><!-- doxytag: member="Tpy::CallChannel::FeatureLocalHoldState" ref="afb30df8bb87f1440e267ff9c45729587" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Tp::Feature <a class="el" href="a00001.html#afb30df8bb87f1440e267ff9c45729587">Tpy::CallChannel::FeatureLocalHoldState</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Feature used in order to access local hold state info.</p>
<p>See local hold state specific methods' documentation for more details. </p>

</div>
</div>
</div>
<p /><address><hr /><div align="center">
<table width="100%" cellspacing="0" border="0"><tr class="address">
<td width="30%">Copyright &copy; 2008-2010 Collabora Ltd. and Nokia Corporation</td>
<td width="30%" align="right"><div align="right">Telepathy-Qt4-Yell 0.1.4</div></td>
</tr></table></div></address>
</body>
</html>
